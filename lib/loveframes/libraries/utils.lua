--[[------------------------------------------------
	-- Love Frames - A GUI library for LOVE --
	-- Copyright (c) 2012-2014 Kenny Shields --
--]]------------------------------------------------

return function(loveframes)
---------- module start ----------

-- util library
--local util = {}

--[[---------------------------------------------------------
	- func: SetState(name)
	- desc: sets the current state
--]]---------------------------------------------------------
function loveframes.SetState(name)
	name = name or "none"
	loveframes.state = name
	loveframes.base.state = name
end

--[[---------------------------------------------------------
	- func: GetState()
	- desc: gets the current state
--]]---------------------------------------------------------
function loveframes.GetState()
	return loveframes.state
end

--[[---------------------------------------------------------
	- func: SetActiveSkin(name)
	- desc: sets the active skin
--]]---------------------------------------------------------
function loveframes.SetActiveSkin(name)
	local skin = name and loveframes.skins[name]
	if not skin then print("SetActiveSkin: no such skin") return end
	
	loveframes.config["ACTIVESKIN"] = name
	local object = loveframes.base
	object:SetSkin(name)
end

--[[---------------------------------------------------------
	- func: GetActiveSkin()
	- desc: gets the active skin
--]]---------------------------------------------------------
function loveframes.GetActiveSkin()
	local index = loveframes.config["ACTIVESKIN"]
	return loveframes.skins[index]
end

--[[---------------------------------------------------------
	- func: GetActiveSkin()
	- desc: gets the active skin
--]]---------------------------------------------------------
function loveframes.SetCursor(cursortype, filename, offset_x, offset_y)
	local file
	if type(filename) == "string" then
		file = love.filesystem.newFile(filename)
	else
		file = filename
	end
	local cursor = love.mouse.newCursor(file, offset_x, offset_y)
	loveframes.cursors[cursortype] = cursor
end
------------------------------------------------------------
--- func: CreateSpriteSheet()
--- desc: Creates a spritesheet out of a file, in equal rectangles
--- containing all subsections  of the file as a ImageData object
-----------------------------------------------------------
--- @param file string
--- @param xsize number
--- @param ysize number
--- @return table spritesheet_table table containing all Image generated by the spritesheet
--- @return table spritesheet_table_raw table containing all ImageData generated by the spritesheet
function loveframes.CreateSpriteSheet(file, xsize, ysize)
	local spritesheet = love.image.newImageData(file)
	local spritesheet_table = {}
	local spritesheet_table_raw = {}
	local w, h = spritesheet:getDimensions()
	local id = 0
	for y = 0, math.floor(h/xsize)-1 do
	for x = 0, math.floor(w/ysize)-1 do
		local sprite = love.image.newImageData(xsize, ysize)
		sprite:paste(spritesheet,0,0,x*xsize,y*ysize,xsize,ysize)
		spritesheet_table[id] = love.graphics.newImage(sprite)
		spritesheet_table_raw[id] = sprite
		id = id + 1
	end
	end
	return spritesheet_table, spritesheet_table_raw
end

function loveframes.CreateSprite(path)
	local imageData = love.image.newImageData(path)
	imageData:mapPixel(function(x, y, r, g, b, a)
		-- Verifica se é magenta (255,0,255)
		-- Normalmente os valores de cor vêm como floats 0..1
		if r == 1 and g == 0 and b == 1 then
			return 1, 0, 1, 0 -- deixa transparente (alpha=0)
		else
			return r, g, b, a
		end
	end)
	local image = love.graphics.newImage(imageData)-- Remove magenta pixels
	return image
end

--[[---------------------------------------------------------
	- func: BoundingBox(x1, x2, y1, y2, w1, w2, h1, h2)
	- desc: checks for a collision between two boxes
	- note: I take no credit for this function
--]]---------------------------------------------------------
function loveframes.BoundingBox(x1, x2, y1, y2, w1, w2, h1, h2)
	if x1 > x2 + w2 - 1 or y1 > y2 + h2 - 1 or x2 > x1 + w1 - 1 or y2 > y1 + h1 - 1 then
		return false
	else
		return true
	end
end

--[[---------------------------------------------------------
	- func: GetCollisions(object, table)
	- desc: gets all objects colliding with the mouse
--]]---------------------------------------------------------
function loveframes.GetCollisions(object, t)
	object = object or loveframes.base
	local x, y = love.mouse.getPosition()
	local curstate = loveframes.state
	local visible = object.visible
	local children = object.children
	local internals = object.internals
	local objectstate = object.state
	local t = t or {}
	
	if objectstate == curstate and visible then
		local objectx = object.x
		local objecty = object.y
		local objectwidth = object.width
		local objectheight = object.height
		local col = loveframes.BoundingBox(x, objectx, y, objecty, 1, objectwidth, 1, objectheight)
		local collide = object.collide
		if col and collide then
			local clickbounds = object.clickbounds
			if clickbounds then
				local cx = clickbounds.x
				local cy = clickbounds.y
				local cwidth = clickbounds.width
				local cheight = clickbounds.height
				local clickcol = loveframes.BoundingBox(x, cx, y, cy, 1, cwidth, 1, cheight)
				if clickcol then
					table.insert(t, object)
				end
			else
				table.insert(t, object)
			end
		end
		if children then
			for k, v in ipairs(children) do
				loveframes.GetCollisions(v, t)
			end
		end
		if internals then
			for k, v in ipairs(internals) do
				local type = v.type
				if type ~= "tooltip" then
					loveframes.GetCollisions(v, t)
				end
			end
		end
	end
	
	return t
end

--[[---------------------------------------------------------
	- func: GetObjectCount(object, table)
	- desc: gets all active objects
--]]---------------------------------------------------------
function loveframes.GetObjectCount(object, c)
	local object = object or loveframes.base
	local internals = object.internals
	local children = object.children
	local c = c or 0
	
	if internals then
		c = c + #internals
		for k, v in ipairs(internals) do
			--c = c + 1
			c = loveframes.GetObjectCount(v, c)
		end
	end
	
	if children then
		c = c + #children
		for k, v in ipairs(children) do
			--c = c + 1
			--loveframes.GetObjectCount(v, c)
			c = loveframes.GetObjectCount(v, c)
		end
	end
	
	return c
end


--[[---------------------------------------------------------
	- func: GetAllObjects(object, table)
	- desc: gets all active objects
--]]---------------------------------------------------------
function loveframes.GetAllObjects(object, t)
	local object = object or loveframes.base
	local internals = object.internals
	local children = object.children
	local t = t or {}
	
	table.insert(t, object)
	
	if internals then
		for k, v in ipairs(internals) do
			loveframes.GetAllObjects(v, t)
		end
	end
	
	if children then
		for k, v in ipairs(children) do
			loveframes.GetAllObjects(v, t)
		end
	end
	
	return t

end

--[[---------------------------------------------------------
	- func: GetDirectoryContents(directory, table)
	- desc: gets the contents of a directory and all of
			its subdirectories
--]]---------------------------------------------------------
function loveframes.GetDirectoryContents(dir, t)
	local dir = dir
	local t = t or {}
	local dirs = {}
	local files = love.filesystem.getDirectoryItems(dir)
	
	for k, v in ipairs(files) do
		local isdir = love.filesystem.getInfo(dir.. "/" ..v) ~= nil and love.filesystem.getInfo(dir.. "/" ..v)["type"] == "directory" --love.filesystem.isDirectory(dir.. "/" ..v)
		if isdir == true then
			table.insert(dirs, dir.. "/" ..v)
		else
			local parts = loveframes.SplitString(v, "([.])")
			local extension = #parts > 1 and parts[#parts]
			if #parts > 1 then
				parts[#parts] = nil
			end
			local name = table.concat(parts, ".")
			table.insert(t, {
				path = dir, 
				fullpath = dir.. "/" ..v, 
				requirepath = loveframes.utf8.gsub(dir, "/", ".") .. "." ..name, 
				name = name, 
				extension = extension
			})
		end
	end
	
	for k, v in ipairs(dirs) do
		t = loveframes.GetDirectoryContents(v, t)
	end
	
	return t
end


--[[---------------------------------------------------------
	- func: Round(num, idp)
	- desc: rounds a number based on the decimal limit
	- note: I take no credit for this function
--]]---------------------------------------------------------
function loveframes.Round(num, idp)
	local mult = 10^(idp or 0)
	
    if num >= 0 then 
		return math.floor(num * mult + 0.5) / mult
    else 
		return math.ceil(num * mult - 0.5) / mult 
	end
end

--[[---------------------------------------------------------
	- func: Mix(num, idp)
	- desc: -- clamp(x, minVal, maxVal): Returns x limited to the [minVal, maxVal] range.
--]]---------------------------------------------------------
function loveframes.Mix(a, b, t)
	return a * (1 - t) + b * t
end

--[[---------------------------------------------------------
	- func: Clamp(x, minVal, maxVal)
	- desc: Returns a value "between" a e b, controlled by T
	- (where t = 0 returns a, t = 1 returns b, and in-between values do a linear transition).
--]]---------------------------------------------------------
function loveframes.Clamp(x, minVal, maxVal)
    if x < minVal then return minVal end
    if x > maxVal then return maxVal end
    return x
end
--[[---------------------------------------------------------
	- func: SplitString(string, pattern)
	- desc: splits a string into a table based on a given pattern
	- note: I take no credit for this function
--]]---------------------------------------------------------
function loveframes.SplitString(str, pat)
	local t = {}  -- NOTE: use {n = 0} in Lua-5.0
	
	if pat == " " then
		local fpat = "(.-)" .. pat
		local last_end = 1
		local s, e, cap = loveframes.utf8.find(str, fpat, 1)
		while s do
			if s ~= #str then
				cap = cap .. " "
			end
			if s ~= 1 or cap ~= "" then
				table.insert(t,cap)
			end
			last_end = e+1
			s, e, cap = loveframes.utf8.find(str, fpat, last_end)
		end
		if last_end <= #str then
			cap = loveframes.utf8.sub(str, last_end)
			table.insert(t, cap)
		end
	else
		local fpat = "(.-)" .. pat
		local last_end = 1
		local s, e, cap = loveframes.utf8.find(str, fpat, 1)
		while s do
			if s ~= 1 or cap ~= "" then
				table.insert(t,cap)
			end
			last_end = e+1
			s, e, cap = loveframes.utf8.find(str, fpat, last_end)
		end
		if last_end <= #str then
			cap = loveframes.utf8.sub(str, last_end)
			table.insert(t, cap)
		end
	end
	
	return t
end

--[[---------------------------------------------------------
	- func: RemoveAll()
	- desc: removes all gui elements
--]]---------------------------------------------------------
function loveframes.RemoveAll()
	loveframes.base.children = {}
	loveframes.base.internals = {}
	
	loveframes.hoverobject = false
	loveframes.downobject = false
	loveframes.modalobject = false
	loveframes.inputobject = false
	loveframes.draggingobject = false
end

--[[---------------------------------------------------------
	- func: AnchorReset()
	- desc: removes all gui elements
--]]---------------------------------------------------------
function loveframes.AnchorReset()
	loveframes.hoverobject = false
	loveframes.downobject = false
	loveframes.draggingobject = false

	loveframes.anchor_x = 0
	loveframes.anchor_y = 0
	loveframes.drag_width = 0
	loveframes.drag_height = 0
	loveframes.drag_x = 0
	loveframes.drag_y = 0
end

function loveframes.GetAnchors()
	return
		loveframes.anchor_x,
		loveframes.anchor_y,
		loveframes.drag_x,
		loveframes.drag_y,
		loveframes.drag_width,
		loveframes.drag_height
end
--[[---------------------------------------------------------
	- func: TableHasValue(table, value)
	- desc: checks to see if a table has a specific value
--]]---------------------------------------------------------
function loveframes.TableHasValue(table, value)
	for k, v in pairs(table) do
		if v == value then
			return true
		end
	end
	
	return false
end

--[[---------------------------------------------------------
	- func: TableHasKey(table, key)
	- desc: checks to see if a table has a specific key
--]]---------------------------------------------------------
function loveframes.TableHasKey(table, key)
	return table[key] ~= nil
	
end

--[[---------------------------------------------------------
	- func: Error(message)
	- desc: displays a formatted error message
--]]---------------------------------------------------------
function loveframes.Error(message)
	error("[Love Frames] " ..message)
end

--[[---------------------------------------------------------
	- func: GetCollisionCount()
	- desc: gets the total number of objects colliding with
			the mouse
--]]---------------------------------------------------------
function loveframes.GetCollisionCount()
	return loveframes.collisioncount or 0
end

--[[---------------------------------------------------------
	- func: GetHover()
	- desc: returns the collision count, can be used to check
			if the mouse is colliding with a visible
			Love Frames object
--]]---------------------------------------------------------
function loveframes.GetHover()
	return loveframes.collisioncount > 1
end

--[[---------------------------------------------------------
	- func: RectangleCollisionCheck(rect1, rect2)
	- desc: checks for a collision between two rectangles
			based on two tables containing rectangle sizes
			and positions
--]]---------------------------------------------------------
function loveframes.RectangleCollisionCheck(rect1, rect2)
	return loveframes.BoundingBox(rect1.x, rect2.x, rect1.y, rect2.y, rect1.width, rect2.width, rect1.height, rect2.height)
end

--[[---------------------------------------------------------
	- func: DeepCopy(orig)
	- desc: copies a table
	- note: I take not credit for this function
--]]---------------------------------------------------------
function loveframes.DeepCopy(orig)
	local orig_type = type(orig)
	local copy
	if orig_type == 'table' then
		copy = {}
		for orig_key, orig_value in next, orig, nil do
			copy[loveframes.DeepCopy(orig_key)] = loveframes.DeepCopy(orig_value)
		end
		setmetatable(copy, loveframes.DeepCopy(getmetatable(orig)))
	else -- number, string, boolean, etc
		copy = orig
	end
	return copy
end

--[[---------------------------------------------------------
	- func: GetHoverObject()
	- desc: returns loveframes.hoverobject
--]]---------------------------------------------------------
function loveframes.GetHoverObject()
	return loveframes.hoverobject
end

--[[---------------------------------------------------------
	- func: GetInputObject()
	- desc: returns loveframes.inputobject
--]]---------------------------------------------------------
function loveframes.GetInputObject()
	return loveframes.inputobject
end

--[[---------------------------------------------------------
	- func: GetDraggingObject()
	- desc: returns loveframes.draggingobject
--]]---------------------------------------------------------
function loveframes.GetDraggingObject()
	return loveframes.draggingobject
end

--[[---------------------------------------------------------
	- func: IsCtrlDown()
	- desc: checks for ctrl, for use with multiselect, copy,
			paste, and such. On OS X it actually looks for cmd.
--]]---------------------------------------------------------
function loveframes.IsCtrlDown()
	if love.system.getOS() == "OS X" then
		return love.keyboard.isDown("lgui") or love.keyboard.isDown("rgui")
	end
	return love.keyboard.isDown("lctrl") or love.keyboard.isDown("rctrl")
end

function loveframes.Color(s, a)
	local r, g, b = string.match(s, '#?(%x%x)(%x%x)(%x%x)')
	if r == nil then return end
	return tonumber(r, 16) / 0xFF, tonumber(g, 16) / 0xFF, tonumber(b, 16) / 0xFF, a or 1
end

--[[---------------------------------------------------------
	- func: draw()
	- desc: draws debug information
--]]---------------------------------------------------------
loveframes.debugwindow = {type = "None", children = nil, parent = nil, x = 0, y = 0, width = 0, height = 0}
loveframes.love_version = table.concat({love.getVersion()}, ".")

function loveframes.DebugDraw()
	--local basedir = loveframes.config["DIRECTORY"]

	local infox = 5
	local infoy = 40
	local topcol = loveframes.debugwindow
	local hoverobject = loveframes.GetHoverObject()
	local inputobject = loveframes.inputobject
	local objects = loveframes.GetObjectCount()
	local collisions = loveframes.collisioncount
	local drawcount = loveframes.drawcount
	local version = loveframes.version
	local stage = loveframes.stage
	local loveversion = loveframes.love_version
	local fps = love.timer.getFPS()
	local deltatime = love.timer.getDelta()
	local font = loveframes.basicfontsmall

	if hoverobject then
		topcol = hoverobject
	end

	if inputobject then
		love.graphics.setColor(0.8, 0.8, 1, 1)
		love.graphics.setLineWidth(2)
		love.graphics.rectangle("line", inputobject.x - 1, inputobject.y - 1, inputobject.width + 2, inputobject.height + 2)
	end

	-- outline the object that the mouse is hovering over
	if hoverobject and hoverobject ~= inputobject then
		love.graphics.setColor(1, 0.8, 0.2, 1)
		love.graphics.setLineWidth(2)
		love.graphics.rectangle("line", hoverobject.x - 1, hoverobject.y - 1, hoverobject.width + 2, hoverobject.height + 2)
	end

	-- draw main debug box
	love.graphics.setFont(font)
	love.graphics.setColor(0,0,0,0.8)
	love.graphics.rectangle("fill", infox, infoy, 200, 130)
	love.graphics.setColor(1,0,0,1)
	love.graphics.print("Love Frames - Debug (" ..version.. " - " ..stage.. ")", infox + 5, infoy + 5)
	love.graphics.setColor(1,1,1,1)
	love.graphics.print("LOVE Version: " ..loveversion, infox + 10, infoy + 20)
	love.graphics.print("FPS: " ..fps.." (".. (1/deltatime)..")", infox + 10, infoy + 30)
	love.graphics.print("Delta Time: " ..deltatime, infox + 10, infoy + 40)
	love.graphics.print("Total Objects: " ..objects, infox + 10, infoy + 50)
	love.graphics.print("Total Collisions: " ..collisions, infox + 10, infoy + 60)
	love.graphics.print("Draw Operations: " ..drawcount, infox + 10, infoy + 70)
	love.graphics.print("Hover Object: " .. tostring(loveframes.hoverobject), infox + 10, infoy+ 80 )
	love.graphics.print("Dragging Object: " .. tostring(loveframes.draggingobject), infox + 10, infoy+ 90 )
	love.graphics.print("Down Object: " .. tostring(loveframes.downobject), infox + 10, infoy+ 100 )
	love.graphics.print("Input Object: " .. tostring(loveframes.inputobject), infox + 10, infoy+ 110 )

	if love.keyboard.isDown "lshift" then
		local ex_info_x = love.mouse.getX()+30
		local ex_info_y = love.mouse.getY()+30

		love.graphics.setColor(0,0,0,0.8)
		love.graphics.rectangle("fill", ex_info_x - 10, ex_info_y - 10, 320, 85)
		love.graphics.setColor(1,1,1,1)

		local children = topcol.children and #topcol.children or 0
		local internals = topcol.internals and #topcol.internals or 0
		local parent = tostring (topcol.parent)
		local item_type = topcol.type

		love.graphics.print("Position: " ..topcol.x.."|"..topcol.y, ex_info_x, ex_info_y + 0)
		love.graphics.print("Size: " ..topcol.width.."|"..topcol.height, ex_info_x, ex_info_y + 10)
		love.graphics.print("Children #: "..children, ex_info_x, ex_info_y + 20)
		love.graphics.print("Internals #: "..internals, ex_info_x, ex_info_y + 30)
		love.graphics.print("Parent: "..parent, ex_info_x, ex_info_y + 40)
		love.graphics.print("Type: "..item_type, ex_info_x, ex_info_y + 50)
	end


	if love.keyboard.isDown "lctrl" then
		local ex_info_x = love.mouse.getX()+30
		local ex_info_y = love.mouse.getY()+30
		local height = 0
		local reverse = false
		for k,v in pairs(topcol) do	height = height + 10 end
		if ex_info_y + height > love.graphics.getHeight() then
			ex_info_y = ex_info_y - height
		end
		love.graphics.setColor(0,0,0,0.8)
		love.graphics.rectangle("fill", ex_info_x - 10, ex_info_y - 10, 320, height+20)
		love.graphics.setColor(1,1,1,1)
		height = 0
		for k, v in pairs(topcol) do
			local str = tostring(v)
			if string.len(str) > 30 then str = "..."..string.sub(str, -30) end

			love.graphics.print(tostring(k)..": ".. str, ex_info_x, ex_info_y + height)
			height = height + 10
		end
	end	
end

--return util

---------- module end ----------
end
